# -*- coding: utf-8 -*-
"""forecast1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z7NxHbvQrMvGwr5dGX7gz65uxrv164XY
"""

import random
import numpy as np
import json
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error,r2_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from datetime import datetime
from dateutil.relativedelta import relativedelta
from prophet import Prophet
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import logging

# Đọc file xlsx
df = pd.read_csv(r"/content/drive/MyDrive/data/UNIS_ORDER.csv")

# Hiển thị 5 dòng đầu tiên
print(df.head())

df_v = df.dropna().reset_index(drop=True)
df_v.info()
df_v

columns_to_keep = [
    'GroupCode',           # Mã hàng
    'GroupName',            # Tên hàng
    'Unit',                # Đơn vị
    'Quantity',            # Số lượng doanh thu
    'DocDate',             # Ngày chứng từ            # Giá giảm
]

df_v = df[columns_to_keep]

df_v.info()

import pandas as pd
import matplotlib.pyplot as plt

# 1. Chuyển DocDate về dạng datetime
df['DocDate'] = pd.to_datetime(df['DocDate'], dayfirst=True, errors='coerce')

# 2. Tính tổng quantity toàn thời gian theo GroupCode, lấy 20 mã hàng bán chạy nhất
top_groups = df.groupby('GroupCode')['Quantity'].sum().nlargest(20).index

# 3. Lọc lại chỉ giữ 20 GroupCode bán chạy nhất
df_top = df[df['GroupCode'].isin(top_groups)].copy()

# 4. Tạo cột tuần bắt đầu (thứ Hai của tuần đó)
df_top['week_start'] = df_top['DocDate'].dt.to_period('W').apply(lambda r: r.start_time)

# 5. Nhóm theo GroupCode và tuần, tính tổng quantity
weekly_quantity = df_top.groupby(['GroupCode', 'week_start'])['Quantity'].sum().reset_index()

# 6. Vẽ biểu đồ cho từng GroupCode
plt.figure(figsize=(14, 8))

for group in weekly_quantity['GroupCode'].unique():
    data = weekly_quantity[weekly_quantity['GroupCode'] == group]
    plt.plot(data['week_start'], data['Quantity'], marker='o', label=str(group))

plt.title('Tổng Quantity theo tuần - Top 20 sản phẩm bán chạy nhất (GroupCode)')
plt.xlabel('Tuần bắt đầu')
plt.ylabel('Quantity')
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left')
plt.tight_layout()
plt.show()

# Chuẩn hóa đơn vị thành chữ thường để so sánh
df_v['Unit'] = df_v['Unit'].str.lower()

# Loại bỏ khoảng trắng thừa trong GroupCode (nếu có)
df_v['GroupCode'] = df_v['GroupCode'].str.strip()

# Lọc các điều kiện: chỉ giữ 'm2' và GroupCode khác 'VANCHUYEN'
df_v_filtered = df_v[(df_v['Unit'] == 'viên') & (df_v['GroupCode'] != 'VANCHUYEN')].copy()

# Kiểm tra kết quả
print("Số dòng còn lại:", len(df_v_filtered))
print(df_v_filtered.head())

# Lọc hàng bán (Quantity > 0)
df_pos = df_v_filtered[df_v_filtered['Quantity'] > 0].copy()

# Lọc hàng trả lại (Quantity < 0)
df_neg = df_v_filtered[df_v_filtered['Quantity'] < 0].copy()

# In thống kê
print("Số dòng hàng bán (Quantity > 0):", len(df_pos))
print("Số dòng hàng trả lại (Quantity < 0):", len(df_neg))

df_pos.info()

# Gộp dữ liệu theo GroupCode và DocDate
df_grouped = (
    df_pos.groupby(['GroupCode', 'DocDate'], as_index=False)
    .agg({
        'Quantity': 'sum',                      # Tổng lượng mua                      # Giá giảm trung bình
    })
)

# Sắp xếp theo thời gian
df_grouped = df_grouped.sort_values('DocDate').reset_index(drop=True)

# Kiểm tra kết quả
df_grouped

# Chuyển DocDate sang datetime
df_grouped['DocDate'] = pd.to_datetime(df_grouped['DocDate'], format='%d/%m/%Y')

# Đếm số ngày xuất hiện (khác nhau) của mỗi GroupCode
day_counts = df_grouped.groupby('GroupCode')['DocDate'].nunique()

# Lọc các sản phẩm chỉ bán đúng 1 ngày
single_day_products = day_counts[day_counts<= 5]

# In kết quả
print(f"Số lượng sản phẩm chỉ bán đúng <= 5 ngày: {len(single_day_products)}")

# (Tùy chọn) In vài ví dụ
print("Ví dụ các sản phẩm chỉ bán <= 5 ngày:")
print(single_day_products.head())

# 1. Chuyển cột DocDate thành kiểu datetime
df_grouped['DocDate'] = pd.to_datetime(df_grouped['DocDate'])

# 2. Tạo cột tuần bắt đầu (thứ Hai đầu tuần)
df_grouped['week_start'] = df_grouped['DocDate'].dt.to_period('W').apply(lambda r: r.start_time)

# 3. Gộp dữ liệu theo GroupCode và tuần
weekly_demand = (
    df_grouped
    .groupby(['GroupCode', 'week_start'], as_index=False)
    .agg({
        'Quantity': 'sum',                          # Tổng số lượng
                             # Mức giảm trung bình
    })
)

# 4. Làm phẳng MultiIndex sau khi groupby
weekly_demand.columns = ['GroupCode', 'Week', 'TotalQuantity']

# 5. Sắp xếp để dễ quan sát
weekly_demand = weekly_demand.sort_values(by=['GroupCode', 'Week']).reset_index(drop=True)

weekly_demand

# Nếu df_grouped là một subset trước đó, hãy copy rõ ràng để tránh cảnh báo
df_grouped = df_grouped.copy()

# Chuyển DocDate sang kiểu datetime (an toàn)
df_grouped.loc[:, 'DocDate'] = pd.to_datetime(df_grouped['DocDate'])

# Đếm số ngày bán khác nhau của mỗi GroupCode
day_counts = df_grouped.groupby('GroupCode')['DocDate'].nunique()

# Lấy danh sách GroupCode xuất hiện <= 5 ngày
few_day_products = day_counts[day_counts <= 5].index

# Loại bỏ các sản phẩm đó khỏi df_grouped
df_grouped = df_grouped[~df_grouped['GroupCode'].isin(few_day_products)].copy()

# Bổ sung cột tuần (lấy thứ Hai đầu tuần)
df_grouped.loc[:, 'week_start'] = (
    df_grouped['DocDate'].dt.to_period('W').apply(lambda r: r.start_time)
)

# Kết quả
print(f"Đã loại bỏ {len(few_day_products)} sản phẩm bán ≤ 5 ngày.")
print(f"Kích thước mới của df_grouped: {df_grouped.shape}")

# Nếu df_grouped là một subset trước đó, hãy copy rõ ràng để tránh cảnh báo
df_grouped = df_grouped.copy()

# Chuyển DocDate sang kiểu datetime (an toàn)
df_grouped.loc[:, 'DocDate'] = pd.to_datetime(df_grouped['DocDate'])

#Đếm số ngày bán khác nhau của mỗi GroupCode
day_counts = df_grouped.groupby('GroupCode')['DocDate'].nunique()

#Lấy danh sách GroupCode chỉ xuất hiện đúng 1 ngày
single_day_products = day_counts[day_counts == 1].index

#Loại bỏ các sản phẩm đó khỏi df_grouped
df_grouped = df_grouped[~df_grouped['GroupCode'].isin(single_day_products)].copy()

#Bổ sung cột tuần nếu cần cho các bước sau
df_grouped.loc[:, 'week_start'] = df_grouped['DocDate'].dt.to_period('W').apply(lambda r: r.start_time)

# Kết quả
print(f"Đã loại bỏ {len(single_day_products)} sản phẩm chỉ bán 1 ngày.")
print(f"Kích thước mới của df_grouped: {df_grouped.shape}")

# 1. Chuyển cột DocDate thành kiểu datetime
df_grouped['DocDate'] = pd.to_datetime(df_grouped['DocDate'])

# 2. Tạo cột tuần bắt đầu (thứ Hai đầu tuần)
df_grouped['week_start'] = df_grouped['DocDate'].dt.to_period('W').apply(lambda r: r.start_time)

# 3. Gộp dữ liệu theo GroupCode và tuần
weekly_demand = (
    df_grouped
    .groupby(['GroupCode', 'week_start'], as_index=False)
    .agg({
        'Quantity': 'sum'                        # Tổng số lượng
                                 # Mức giảm trung bình
    })
)

# 4. Làm phẳng MultiIndex sau khi groupby
weekly_demand.columns = ['GroupCode', 'Week', 'TotalQuantity']

# 5. Sắp xếp để dễ quan sát
weekly_demand = weekly_demand.sort_values(by=['GroupCode', 'Week']).reset_index(drop=True)

weekly_demand

weekly_demand.to_csv("weekly_demand.csv", index=False, encoding="utf-8-sig")

"""# XG BOOST"""

import pandas as pd
import numpy as np
import xgboost as xgb
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import math

def create_features(df):
    df['week_num'] = df['ds'].dt.isocalendar().week
    df['month'] = df['ds'].dt.month
    df['quarter'] = df['ds'].dt.quarter
    df['year'] = df['ds'].dt.year
    df['lag_1'] = df['y'].shift(1)
    df['rolling_mean_3'] = df['y'].rolling(window=2).mean()
    df['rolling_std_3'] = df['y'].rolling(window=2).std()
    return df

def evaluate_xgb(df_prod, test_ratio=0.3, plot=True):
    if df_prod['TotalQuantity'].count() < 6:
        print("Bỏ sản phẩm - dữ liệu quá ít")
        return None, None, None, None, None

    df = df_prod[['Week', 'TotalQuantity']].copy()
    df.columns = ['ds', 'y']
    df['ds'] = pd.to_datetime(df['ds'])
    df = df.sort_values('ds').reset_index(drop=True)

    df = create_features(df)
    df = df.dropna().reset_index(drop=True)  # Bỏ các dòng chứa NaN do rolling/lag

    split_idx = math.ceil(len(df) * (1 - test_ratio))
    train_df = df.iloc[:split_idx]
    test_df = df.iloc[split_idx:]

    features = ['week_num', 'month', 'quarter', 'year', 'lag_1', 'rolling_mean_3', 'rolling_std_3']

    if train_df.shape[0] < 5 or test_df.shape[0] < 2:
        print("Train/test quá ngắn")
        return None, None, None, None, None

    model = xgb.XGBRegressor(n_estimators=100, learning_rate=0.1)
    model.fit(train_df[features], train_df['y'])

    y_pred = model.predict(test_df[features])
    test_df['yhat'] = y_pred

    mae = mean_absolute_error(test_df['y'], test_df['yhat'])
    rmse = np.sqrt(mean_squared_error(test_df['y'], test_df['yhat']))
    mape = np.mean(np.abs((test_df['y'] - test_df['yhat']) / (test_df['y'] + 1e-6))) * 100

    if plot:
        plt.figure(figsize=(12, 5))
        plt.plot(df['ds'], df['y'], label='Thực tế')
        plt.plot(test_df['ds'], test_df['yhat'], label='Dự báo (XGBoost)', linestyle='--')
        plt.axvline(test_df['ds'].iloc[0], color='gray', linestyle=':')
        plt.legend()
        plt.title(f'XGBoost Forecast | GroupCode: {df_prod["GroupCode"].iloc[0]}')
        plt.grid(True)
        plt.show()

    return model, test_df[['ds', 'y', 'yhat']], mae, rmse, mape

results_xgb = []

group_codes = weekly_demand['GroupCode'].unique()

for group_code in tqdm(group_codes):
    df_prod = weekly_demand[weekly_demand['GroupCode'] == group_code].copy()

    try:
        model, df_forecast, mae, rmse, mape = evaluate_xgb(df_prod, test_ratio=0.3, plot=False)
        if df_forecast is not None:
            results_xgb.append({
                'GroupCode': group_code,
                'mae': mae,
                'rmse': rmse,
                'mape': mape
            })
    except Exception as e:
        print(f"Lỗi tại {group_code}: {e}")
        continue

results_xgb_df = pd.DataFrame(results_xgb)
top_5_xgb = results_xgb_df.sort_values(by='mape').head(5)

print("Top 5 sản phẩm có sai số thấp nhất (XGBoost):")
print(top_5_xgb)

# Vẽ cho 3 sản phẩm
for group_code in top_5_xgb['GroupCode']:
    df_prod = weekly_demand[weekly_demand['GroupCode'] == group_code].copy()
    _ = evaluate_xgb(df_prod, test_ratio=0.3, plot=True)

# Lọc các sản phẩm có mape < 200
total_products = len(results_xgb_df)
print(total_products)
filtered_df = results_xgb_df[results_xgb_df['mape'] < 10]

# Tính trung bình các chỉ số trong nhóm này
average_mae = filtered_df['mae'].mean()
average_rmse = filtered_df['rmse'].mean()
average_mape = filtered_df['mape'].mean()

print(f"Số sản phẩm có MAPE < 100: {len(filtered_df)}")
print("Danh sách GroupCode các sản phẩm có MAPE < 100:")
print(filtered_df['GroupCode'].tolist())

print("\nTrung bình các chỉ số của nhóm sản phẩm này:")
print(f"Average MAE: {average_mae:.4f}")
print(f"Average RMSE: {average_rmse:.4f}")
print(f"Average MAPE: {average_mape:.4f}%")

import numpy as np
import pandas as pd

def create_features(df):
    # Giả sử df có cột 'ds' (datetime) và 'y' (giá trị)
    df = df.copy()

    # Đặc trưng thời gian cơ bản
    df['week_num'] = df['ds'].dt.isocalendar().week.astype(int)
    df['month'] = df['ds'].dt.month
    df['quarter'] = df['ds'].dt.quarter
    df['year'] = df['ds'].dt.year
    df['day_of_week'] = df['ds'].dt.dayofweek  # 0=Monday, 6=Sunday

    # Đặc trưng dạng sin-cos cho tính chu kỳ
    df['week_sin'] = np.sin(2 * np.pi * df['week_num'] / 52)
    df['week_cos'] = np.cos(2 * np.pi * df['week_num'] / 52)
    df['month_sin'] = np.sin(2 * np.pi * df['month'] / 12)
    df['month_cos'] = np.cos(2 * np.pi * df['month'] / 12)

    # Lag features
    df['lag_1'] = df['y'].shift(1)
    df['lag_2'] = df['y'].shift(2)
    df['lag_4'] = df['y'].shift(4)  # 4 tuần trước

    # Rolling statistics
    df['rolling_mean_3'] = df['y'].rolling(window=2).mean()
    df['rolling_std_3'] = df['y'].rolling(window=2).std()
    df['rolling_max_3'] = df['y'].rolling(window=2).max()
    df['rolling_min_3'] = df['y'].rolling(window=2).min()

    # % thay đổi so với tuần trước
    df['pct_change_1'] = df['y'].pct_change(periods=1)
    df['pct_change_4'] = df['y'].pct_change(periods=4)

    return df
def evaluate_xgb(df_prod, test_ratio=0.3, plot=True):
    if df_prod['TotalQuantity'].count() < 6:
        print("Bỏ sản phẩm - dữ liệu quá ít")
        return None, None, None, None, None

    df = df_prod[['Week', 'TotalQuantity']].copy()
    df.columns = ['ds', 'y']
    df['ds'] = pd.to_datetime(df['ds'])
    df = df.sort_values('ds').reset_index(drop=True)

    df = create_features(df)
    df = df.dropna().reset_index(drop=True)  # Bỏ các dòng chứa NaN do rolling/lag

    split_idx = math.ceil(len(df) * (1 - test_ratio))
    train_df = df.iloc[:split_idx]
    test_df = df.iloc[split_idx:]

    features = [
    'week_num', 'month', 'quarter', 'year', 'day_of_week',
    'week_sin', 'week_cos', 'month_sin', 'month_cos',
    'lag_1', 'lag_2', 'lag_4',
    'rolling_mean_3', 'rolling_std_3', 'rolling_max_3', 'rolling_min_3',
    'pct_change_1', 'pct_change_4'
    ]


    if train_df.shape[0] < 5 or test_df.shape[0] < 2:
        print("Train/test quá ngắn")
        return None, None, None, None, None

    model = xgb.XGBRegressor(n_estimators=100, learning_rate=0.1)
    model.fit(train_df[features], train_df['y'])

    y_pred = model.predict(test_df[features])
    test_df['yhat'] = y_pred

    mae = mean_absolute_error(test_df['y'], test_df['yhat'])
    rmse = np.sqrt(mean_squared_error(test_df['y'], test_df['yhat']))
    mape = np.mean(np.abs((test_df['y'] - test_df['yhat']) / (test_df['y'] + 1e-6))) * 100

    if plot:
        plt.figure(figsize=(12, 5))
        plt.plot(df['ds'], df['y'], label='Thực tế')
        plt.plot(test_df['ds'], test_df['yhat'], label='Dự báo (XGBoost)', linestyle='--')
        plt.axvline(test_df['ds'].iloc[0], color='gray', linestyle=':')
        plt.legend()
        plt.title(f'XGBoost Forecast | GroupCode: {df_prod["GroupCode"].iloc[0]}')
        plt.grid(True)
        plt.show()

    return model, test_df[['ds', 'y', 'yhat']], mae, rmse, mape

"""## RESULT"""

results_xgb = []

group_codes = weekly_demand['GroupCode'].unique()

for group_code in tqdm(group_codes):
    df_prod = weekly_demand[weekly_demand['GroupCode'] == group_code].copy()

    try:
        model, df_forecast, mae, rmse, mape = evaluate_xgb(df_prod, test_ratio=0.3, plot=False)
        if df_forecast is not None:
            results_xgb.append({
                'GroupCode': group_code,
                'mae': mae,
                'rmse': rmse,
                'mape': mape
            })
    except Exception as e:
        print(f"Lỗi tại {group_code}: {e}")
        continue

results_xgb_df = pd.DataFrame(results_xgb)
top_5_xgb = results_xgb_df.sort_values(by='mape').head(20)

print("Top 5 sản phẩm có sai số thấp nhất (XGBoost):")
print(top_5_xgb)

# Vẽ cho 3 sản phẩm
for group_code in top_5_xgb['GroupCode']:
    df_prod = weekly_demand[weekly_demand['GroupCode'] == group_code].copy()
    _ = evaluate_xgb(df_prod, test_ratio=0.3, plot=True)

"""## TRAIN RESULT AVERAGE"""

# Lọc các sản phẩm có mape < 100
total_products = len(results_xgb_df)
print(total_products)
filtered_df = results_xgb_df[results_xgb_df['mape']< 50]

# Tính trung bình các chỉ số trong nhóm này
average_mae = filtered_df['mae'].mean()
average_rmse = filtered_df['rmse'].mean()
average_mape = filtered_df['mape'].mean()

print(f"Số sản phẩm có MAPE < 100: {len(filtered_df)}")
print("Danh sách GroupCode các sản phẩm có MAPE < 100:")
print(filtered_df['GroupCode'].tolist())

print("\nTrung bình các chỉ số của nhóm sản phẩm này:")
print(f"Average MAE: {average_mae:.4f}")
print(f"Average RMSE: {average_rmse:.4f}")
print(f"Average MAPE: {average_mape:.4f}%")

results_xgb_df = pd.DataFrame(results_xgb)
results_xgb_df.to_csv("/content/drive/MyDrive/data/xgboost_metrics_all_update.csv", index=False, encoding="utf-8-sig")

"""# LSTM

## TRAIN MODEL
"""

! pip install prophet

def evaluate_prophet(df_prod, test_ratio=0.3, plot=True):
    if df_prod['TotalQuantity'].count() < 6:
        print("Bỏ sản phẩm - dữ liệu quá ít")
        return None, None, None, None, None

    # Chuẩn bị dữ liệu cho Prophet
    df = df_prod[['Week', 'TotalQuantity']].copy()
    df.columns = ['ds', 'y']
    df['ds'] = pd.to_datetime(df['ds'])
    df = df.sort_values('ds').reset_index(drop=True)

    split_idx = math.ceil(len(df) * (1 - test_ratio))
    train_df = df.iloc[:split_idx]
    test_df = df.iloc[split_idx:]

    if train_df.shape[0] < 5 or test_df.shape[0] < 2:
        print("Train/test quá ngắn")
        return None, None, None, None, None

    # Huấn luyện Prophet
    model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
    model.fit(train_df)

    # Tạo DataFrame future cho test
    future = test_df[['ds']].copy()
    forecast = model.predict(future)

    # Ghép kết quả dự báo
    test_df = test_df.merge(forecast[['ds', 'yhat']], on='ds', how='left')

    # Tính metrics
    mae = mean_absolute_error(test_df['y'], test_df['yhat'])
    rmse = np.sqrt(mean_squared_error(test_df['y'], test_df['yhat']))
    mape = np.mean(np.abs((test_df['y'] - test_df['yhat']) / (test_df['y'] + 1e-6))) * 100

    # Vẽ
    if plot:
        plt.figure(figsize=(12, 5))
        plt.plot(df['ds'], df['y'], label='Thực tế')
        plt.plot(test_df['ds'], test_df['yhat'], label='Dự báo (Prophet)', linestyle='--')
        plt.axvline(test_df['ds'].iloc[0], color='gray', linestyle=':')
        plt.legend()
        plt.title(f'Prophet Forecast | GroupCode: {df_prod["GroupCode"].iloc[0]}')
        plt.grid(True)
        plt.show()

    return model, test_df[['ds', 'y', 'yhat']], mae, rmse, mape

# --- Chạy cho toàn bộ sản phẩm ---
results_prophet = []

group_codes = weekly_demand['GroupCode'].unique()

for group_code in tqdm(group_codes):
    df_prod = weekly_demand[weekly_demand['GroupCode'] == group_code].copy()

    try:
        model, df_forecast, mae, rmse, mape = evaluate_prophet(df_prod, test_ratio=0.3, plot=False)
        if df_forecast is not None:
            results_prophet.append({
                'GroupCode': group_code,
                'mae': mae,
                'rmse': rmse,
                'mape': mape
            })
    except Exception as e:
        print(f"Lỗi tại {group_code}: {e}")
        continue

# Lưu kết quả metrics
results_prophet_df = pd.DataFrame(results_prophet)
results_prophet_df.to_csv("prophet_metrics_all.csv", index=False, encoding="utf-8-sig")

# Top 5 sản phẩm có MAPE thấp nhất
top_5_prophet = results_prophet_df.sort_values(by='mape').head(5)
print("Top 5 sản phẩm có sai số thấp nhất (Prophet):")
print(top_5_prophet)

# Vẽ cho 3 sản phẩm tốt nhất
for group_code in top_5_prophet['GroupCode']:
    df_prod = weekly_demand[weekly_demand['GroupCode'] == group_code].copy()
    _ = evaluate_prophet(df_prod, test_ratio=0.3, plot=True)